* Package-Initialize and repos
** COMMENT melpa and org repos
#+BEGIN_SRC emacs-lisp 
  (require 'package)
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
  (package-initialize)
#+END_SRC

#+RESULTS:


** package-initialize-packages
#+BEGIN_SRC emacs-lisp
    (custom-set-variables
     ;; custom-set-variables was added by Custom.
     ;; If you edit it by hand, you could mess it up, so be careful.
     ;; Your init ilfet should contain only one such instance.
     ;; If there is more than one, they won't work right.
     '(ansi-color-faces-vector
       [default default default italic underline success warning error])
     '(custom-safe-themes
       (quote
        ("43c1a8090ed19ab3c0b1490ce412f78f157d69a29828aa977dae941b994b4147" default)))
     '(helm-ff-auto-update-initial-value t)
     '(helm-gtags-auto-update t)
     '(helm-gtags-ignore-case t)
     '(helm-gtags-path-style (quote relative))
  '(org-export-show-temporary-export-buffer t)
     '(org-modules
       (quote
        (org-bbdb org-bibtex org-docview org-gnus org-info org-irc org-mhe org-rmail org-w3m)))
     '(org-startup-truncated t)
     )
#+END_SRC

#+RESULTS:

* use-package
#+BEGIN_SRC emacs-lisp
;; ---- use-package initialization, make sure use-package.el is cloned into ~/.emacs.d
;; This is only needed once, near the top of the file
(eval-when-compile
  ;; Following line is not needed if use-package.el is in ~/.emacs.d
  ;; (add-to-list 'load-path "<path where use-package is installed>")
  (require 'use-package))

;; use-package
(setq use-package-always-ensure t)
#+END_SRC

#+RESULTS:
: t

* general emacs behaviour
customize annoyng defaults
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
(global-auto-revert-mode 1)
(setq inhibit-startup-message t) 

(scroll-bar-mode 0)
(tool-bar-mode 0)
(menu-bar-mode 1)

(savehist-mode 1)
(show-paren-mode 1)
(setq show-paren-delay 0)
#+END_SRC

#+RESULTS:
: 0

Disable startup screen when opening a file from command line
#+BEGIN_SRC emacs-lisp
(defun my-inhibit-startup-screen-always ()
  ;; Startup screen inhibitor for `command-line-functions`.
  ;; Inhibits startup screen on the first unrecognised option.
  (ignore (setq inhibit-startup-screen t)))

(add-hook 'command-line-functions #'my-inhibit-startup-screen-always)
#+END_SRC

Set scrolling behaviour (that is almost like smooth-scrolling)
#+BEGIN_SRC emacs-lisp
;; (setq redisplay-dont-pause t
;;   scroll-margin 5
;;   scroll-step 1
;;   scroll-conservative
;;   scroll-preserve-screen-position 1)

(setq scroll-step 1)
(setq scroll-conservatively 10000)
(setq auto-window-vscroll nil)
(setq scroll-margin 5)
#+END_SRC
#+RESULTS:
: 5

Place auto-save files into seperate directory, away from the original files, to not have them be unintentionally stored in e.g. a git commit#+
#+BEGIN_SRC emacs-lisp
  (let (my-backup-folder)
    (setq my-backup-folder (concat user-emacs-directory ".saves"))
    (if (not (file-exists-p my-backup-folder))
        (make-directory my-backup-folder))
  
    (setq backup-directory-alist (quote (("." . "~/.saves"))))
    ;; (setq backup-directory-alist `(("." . ,my-backup-folder)))
    (setq backup-by-copying t)
  )
#+END_SRC

#+RESULTS:
: t

Quick up and down navigation
#+BEGIN_SRC emacs-lisp
;; replaces forward-sentence
(global-set-key (kbd "M-e")
  (lambda ()
    (interactive)
    (setq this-command 'next-line)
    (next-line 3)))

;; replaces backward-sentence
(global-set-key (kbd "M-a")
  (lambda ()
    (interactive)
    (setq this-command 'previous-line)
    (previous-line 3)))
#+END_SRC

** COMMENT startup size and position
#+BEGIN_SRC emacs-lisp
(if (display-graphic-p)
  (progn
    (setq frame-resize-pixelwise t)
    (set-frame-position (selected-frame) 0 0)
    ;; (set-frame-size (selected-frame) (truncate (/ 1920 2.053)) 600 t)
    (set-frame-size (selected-frame) 905 600 t))
  (progn
    (menu-bar-mode -1))
  )
#+END_SRC

#+RESULTS:

* general packages
** helm
Does a lot of useful auto-completion stuff all over emacs, e.g. when finding files or functions.
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :config
  (helm-mode 1)
  ;; (define-key global-map [remap find-file] 'helm-find-files)
  (global-set-key (kbd "C-, C-f") 'helm-find-files)

  ;; select buffers with C-Space, delete selection with M-S-d
  (global-set-key (kbd "C-2") 'helm-mini))
#+END_SRC

#+RESULTS:
: t

** COMMENT hide-mode-line
#+BEGIN_SRC emacs-lisp
(use-package hide-mode-line
  :ensure t)
#+END_SRC

#+RESULTS:

** COMMENT darkroom
#+BEGIN_SRC emacs-lisp
(use-package darkroom
  :ensure t
  :config
  (setq darkroom-text-scale-increase 0)
  (add-hook 'darkroom-mode-hook 'visual-line-mode)
  (add-hook 'darkroom-mode-hook (lambda () (scroll-bar-mode 0)))
  (add-hook 'darkroom-mode-hook (lambda () (tool-bar-mode 0)))
  (add-hook 'darkroom-mode-hook (lambda () (menu-bar-mode 0)))

  (scroll-bar-mode 0)
  (tool-bar-mode 0)
  (menu-bar-mode 0)

  (global-set-key (kbd "C-c d") 'darkroom-mode))
#+END_SRC

#+RESULTS:
: t

** material-theme
#+BEGIN_SRC emacs-lisp
(use-package material-theme
  :ensure t)

;; (load-theme 'material t) ;; load material theme
#+END_SRC

#+RESULTS:

** COMMENT desktop+
#+BEGIN_SRC emacs-lisp
(use-package desktop+
  :config
  (setq my-cloud-dir "~/Dropbox/")
  
  (let ((default-directory my-cloud-dir))
    (setq my-cloud-linkedapps-dir (expand-file-name "1LinkedApps/")))
  
  (let ((default-directory my-cloud-linkedapps-dir))
    (setq my-cloud-emacs-dir (expand-file-name "emacs/")))
  
  (let ((default-directory my-cloud-emacs-dir))
  (setq my-cloud-emacs-desktops-dir (expand-file-name "desktops/")))

  ;; the given directory should be a link to dropbox
  ;; with a central managed git repository

  (setq emacsd-desktops-dir "~/.emacs.d/desktops/")
  (if (file-directory-p emacsd-desktops-dir)
      (progn (message (format "%s exists" emacsd-desktops-dir)))
    (progn (message (format "%s doesn't exit, linking it to %s" emacsd-desktops-dir my-cloud-emacs-desktops-dir))
	   (shell-command-to-string
	    (format "ln -s %s %s" my-cloud-emacs-desktops-dir (file-name-directory (directory-file-name emacsd-desktops-dir))))))

  (setq desktop+-base-dir emacsd-desktops-dir)

  ;; ;; BEGIN remember last session 
  ;; (defun read-lines (filePath)
  ;;   "Return a list of lines of a file at filePath."
  ;;   (with-temp-buffer
  ;;     (insert-file-contents filePath)
  ;;     (split-string (buffer-string) "\n" t)))
  ;; 
  ;; (setq last-session-file-name ".lastsessionname")
  ;; 
  ;; (defun load-last-session ()
  ;;   (interactive)
  ;;   (desktop+-load (nth 0 (read-lines last-session-file-name)))
  ;;   )

  ;; ;; (add-hook 'kill-emacs-hook
  ;; ;; 	  '(lambda ()
  ;; ;; 	     (write-region (file-name-nondirectory (directory-file-name desktop-dirname)) nil last-session-file-name))
  ;; ;; 	  )
  ;; ;; 
  ;; ;; (global-set-key (kbd "C-c C-l C-l") 'load-last-session)
  ;; ;; ;; END remember last session 
  )
#+END_SRC

#+RESULTS:
: t

** winner
#+BEGIN_SRC emacs-lisp
(use-package winner
  :config
    (when (fboundp 'winner-mode)
      (winner-mode 1))
    (define-key winner-mode-map (kbd "C-c h") 'winner-undo)
    (define-key winner-mode-map (kbd "C-c l") 'winner-redo))
#+END_SRC

#+RESULTS:
: t

** org-mode
#+BEGIN_SRC emacs-lisp
  (use-package org
    :config
    ;; ---- general behaviour of org-mode
    (setq org-startup-indented t)

    (add-hook 'org-mode-hook
              (lambda ()
                (visual-line-mode 1)))

    (add-hook 'org-mode-hook
              (lambda ()
                (show-paren-mode 1)))

    ;; custom org-mode functions
    (defun org-archive-done-tasks-subtree ()
      (interactive)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
      "/DONE" 'tree))

    (defun org-archive-done-tasks-file ()
      (interactive)
      (org-map-entries
       (lambda ()
         (org-archive-subtree)
         (setq org-map-continue-from (outline-previous-heading)))
                       "/DONE"
                       'file))

    ;; ----- latex workflow

    ;; bigger latex fragment
    (plist-put org-format-latex-options :scale 1.5)

    ;; export body shortcut
    (fset 'latex-body-export
          (lambda (&optional arg)
            "Keyboard macro for LaTeX body export only."
            (interactive "p")
            (kmacro-exec-ring-item (quote ("ll" 0 "%d"))
                                   arg)))

    (defun my-org-latex-export-and-save ()
      (interactive)
      (latex-body-export)
      (save-buffer))

    (eval-after-load 'evil-ex
      '(evil-ex-define-cmd "wl[atex]" 'my-org-latex-export-and-save))

    (setq org-latex-pdf-process
          '("latexmk -pdf -pdflatex=lualatex -bibtex %f"))

    ;; add koma-article to org-mode
    (with-eval-after-load "ox-latex"
      (add-to-list 'org-latex-classes
                   '("koma-article" "\\documentclass{scrartcl}"
                     ("\\section{%s}" . "\\section*{%s}")
                     ("\\subsection{%s}" . "\\subsection*{%s}")
                     ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                     ("\\paragraph{%s}" . "\\paragraph*{%s}")
                     ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))

    ;; ---- org-babel ----
    (org-babel-do-load-languages
      'org-babel-load-languages
      '((emacs-lisp . t)
        (python . t)
        (shell . t)
        (haskell . t)))

    (setq org-confirm-babel-evaluate nil)
    ;; ------------

    ;; ------- latex fragments preview, automate
     (defvar kk/org-latex-fragment-last nil
      "Holds last fragment/environment you were on.")

    (defun kk/org-in-latex-fragment-p ()
      "Return the point where the latex fragment begins, if inside
    a latex fragment. Else return false"
      (let* ((el (org-element-context))
             (el-type (car el)))
        (and (or (eq 'latex-fragment el-type) (eq 'latex-environment el-type))
            (org-element-property :begin el))))

    (defun kk/org-latex-fragment-toggle ()
      "Toggle a latex fragment image "
      (and (eq 'org-mode major-mode)
       (let ((begin (kk/org-in-latex-fragment-p)))
             (cond
              ;; were on a fragment and now on a new fragment
              ((and
                ;; fragment we were on
                kk/org-latex-fragment-last
                ;; and are on a fragment now
                begin

                ;; but not on the last one this is a little tricky. as you edit the
                ;; fragment, it is not equal to the last one. We use the begin
                ;; property which is less likely to change for the comparison.
                (not (and kk/org-latex-fragment-last
              (= begin
                 kk/org-latex-fragment-last))))
               ;; go back to last one and put image back, provided there is still a fragment there
               (save-excursion
                 (goto-char kk/org-latex-fragment-last)
                 (when (kk/org-in-latex-fragment-p) (org-preview-latex-fragment))

                 ;; now remove current image
                 (goto-char begin)
                 (let ((ov (loop for ov in (org--list-latex-overlays)
                                 if
                                 (and
                  (<= (overlay-start ov) (point))
                  (>= (overlay-end ov) (point)))
                                 return ov)))
           (when ov
                     (delete-overlay ov)))
                 ;; and save new fragment
                 (setq kk/org-latex-fragment-last begin)))

              ;; were on a fragment and now are not on a fragment
              ((and
                ;; not on a fragment now
                (not begin)
                ;; but we were on one
                kk/org-latex-fragment-last)
               ;; put image back on, provided that there is still a fragment here.
               (save-excursion
                 (goto-char kk/org-latex-fragment-last)
                 (when (kk/org-in-latex-fragment-p) (org-preview-latex-fragment)))

               ;; unset last fragment
               (setq kk/org-latex-fragment-last nil))

              ;; were not on a fragment, and now are
              ((and
                ;; we were not one one
                (not kk/org-latex-fragment-last)
                ;; but now we are
                begin)
               ;; remove imagex
               (save-excursion
                 (goto-char begin)
                 (let ((ov (loop for ov in (org--list-latex-overlays)
                                 if
                                 (and
                  (<= (overlay-start ov) (point))
                  (>= (overlay-end ov) (point)))
                                 return ov)))
           (when ov
                     (delete-overlay ov))))
               (setq kk/org-latex-fragment-last begin))))))

    (defvar auto-compile-cursor-traversed-latex-fragments t
      "toggle variable nil or t")

    (defun toggle-org-latex-fragment ()
      "Toggle on/off the post-command-hook
  kk/org-latex-fragment-toggle"
      (if auto-compile-cursor-traversed-latex-fragments
          (progn
            ;; it was set to t, so now set it to nil
            (setq auto-compile-cursor-traversed-latex-fragments nil)
            (remove-hook 'post-command-hook 'kk/org-latex-fragment-toggle t))
        ;; else, activate it
        (setq auto-compile-cursor-traversed-latex-fragments t)
        (add-hook 'post-command-hook 'kk/org-latex-fragment-toggle t))))

    ;; -------
#+END_SRC

#+RESULTS:
: t

** evil-mode
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :init (setq evil-want-C-u-scroll t)(add-to-list 'load-path "~/.emacs.d/evil")(setq evil-want-integration t)(setq evil-want-keybinding nil):config
    ;; (evil-mode 1)
    (add-to-list 'evil-emacs-state-modes 'org-mode)
    (add-to-list 'evil-emacs-state-modes 'nav-mode)
    (add-to-list 'evil-emacs-state-modes 'pdf-occur-buffer-mode)
    (add-to-list 'evil-emacs-state-modes 'emacs-lisp-mode)
    (add-to-list 'evil-emacs-state-modes 'help-mode)
    ;; only ever go up/down visual lines
    (define-key evil-normal-state-map (kbd "j") 'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "k") 'evil-previous-visual-line))
#+END_SRC

#+RESULTS:
: t

** evil-collection
#+BEGIN_SRC emacs-lisp
  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init)
    (defun mysethistoryforwardbackward ()
      (interactive)
      (evil-define-key 'normal pdf-view-mode-map (kbd "B") 'pdf-history-backward)
      (evil-define-key 'normal pdf-view-mode-map (kbd "F") 'pdf-history-forward)
      (add-hook 'pdf-view-mode-hook #'evil-normalize-keymaps))
      (add-hook 'pdf-view-mode-hook #'mysethistoryforwardbackward))
#+END_SRC

#+RESULTS:
: t

** COMMENT linum-relative
#+BEGIN_SRC emacs-lisp
  (use-package linum-relative
    :config
    (add-hook 'prog-mode-hook 'linum-on)
    (setq linum-relative-current-symbol "")
    (linum-relative-mode))
#+END_SRC

#+RESULTS:
: t

** pdf-tools
 PDF Viewer for Emacs
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :config
  (define-key pdf-view-mode-map (kbd "C-c C-l") 'org-store-link)
  (define-key pdf-view-mode-map (kbd "C-c C-s") 'pdf-view-auto-slice-minor-mode)
  ;; (add-hook 'pdf-tools-enabled-hook 'pdf-view-midnight-minor-mode)
)
#+END_SRC

#+RESULTS:
: t

** org-pdfview
#+BEGIN_SRC emacs-lisp
  (use-package org-pdfview
    ;; org-pdfview: it's not a minor-mode, just a few functions that adapt
    ;; orgs behavior if pdf-view-mode is enabled, e.g. for storing links,
    ;; a special function is called
    :config
      (pdf-tools-install)
      ;; (pdf-loader-install)

      ;; override a function in org-pdfview so that the description is not the whole file path
      (eval-after-load "org-pdfview"
        (defun org-pdfview-store-link ()
          "  Store a link to a pdfview buffer."
          (when (eq major-mode 'pdf-view-mode)
            ;; This buffer is in pdf-view-mode
            (let* ((path buffer-file-name)
                (page (pdf-view-current-page))
                (link (concat "pdfview:" path "::" (number-to-string page))))
              (org-store-link-props
               :type "pdfview"
               :link link
               :description
               (concat (nth 0 (split-string (file-name-nondirectory buffer-file-name) "-"))
                       "::"
                       (number-to-string (pdf-view-current-page)))))))))
#+END_SRC

#+RESULTS:
: t

** COMMENT org-download
#+BEGIN_SRC emacs-lisp
(use-package org-download
  :config
  (add-hook 'dired-mode-hook 'org-download-enable))
#+END_SRC

#+RESULTS:
: t

** org-ref
#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :after org)
#+END_SRC

#+RESULTS:

** COMMENT centered-window
#+BEGIN_SRC emacs-lisp
(use-package centered-window 
  :ensure t)
#+END_SRC

#+RESULTS:

** multi-term
#+BEGIN_SRC emacs-lisp
(use-package multi-term
  :config

  ; (setq multi-term-program "/usr/local/bin/zsh")
  (setq multi-term-program "/usr/bin/zsh")

  (if (not (file-exists-p multi-term-program))
    (progn 
      (message (concat multi-term-program " does not exist"))))
  
  (add-hook 'term-mode-hook
            (lambda ()
              (setq term-buffer-maximum-size 10000)))
  
  (add-hook 'term-mode-hook
            (lambda ()
              (setq show-trailing-whitespace nil)))
  
  (defcustom term-unbind-key-list
    '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
    "The key list that will need to be unbind."
    :type 'list
    :group 'multi-term)
 

  ; these keys hold when in evil insert mode
  (defcustom term-bind-key-alist
    '(
      ("C-c C-c" . term-interrupt-subjob)
      ("C-p" . previous-line)
      ("C-n" . next-line)
      ("C-s" . isearch-forward)
      ("C-r" . isearch-backward)
      ("C-m" . term-send-raw)
      ("M-f" . term-send-forward-word)
      ("M-b" . term-send-backward-word)
      ("M-o" . term-send-backspace)
      ("M-p" . term-send-up)
      ("M-n" . term-send-down)
      ("M-M" . term-send-forward-kill-word)
      ("M-N" . term-send-backward-kill-word)
      ("M-r" . term-send-reverse-search-history)
      ("M-," . term-send-input)
      ("M-." . comint-dynamic-complete)
      ("C-, p" . multi-term-prev)
      ("C-, n" . multi-term-next)
)

    "The key alist that will need to be bind.
     If you do not like default setup, modify it, with (KEY . COMMAND) format."
    :type 'alist
    :group 'multi-term)
  
  ; open multi-terminal
  (global-set-key (kbd "C-x C-m C-m") 'multi-term)
  (global-set-key (kbd "C-, n") 'multi-term-next)
  ; (global-set-key (kbd "C-, p") 'multi-term-prev))

  ; these keys hold when in evil normal mode
  (define-key term-mode-map (kbd "C-, n") 'multi-term-next)
  (define-key term-mode-map (kbd "C-, p") 'multi-term-prev))

#+END_SRC

#+RESULTS:
: t

** COMMENT sr-speedbar
#+BEGIN_SRC emacs-lisp
(use-package sr-speedbar
  :ensure t
  :config
  (global-set-key (kbd "C-, n") 'sr-speedbar-toggle))

#+END_SRC

#+RESULTS:
: t

** COMMENT neotree
#+BEGIN_SRC emacs-lisp
(use-package neotree
  :config 
  (global-set-key (kbd "C-, t") 'neotree-toggle))
#+END_SRC

#+RESULTS:
: t

** COMMENT smooth-scrolling
#+BEGIN_SRC emacs-lisp
(use-package smooth-scrolling
:ensure t
:config
;; I tried to figure out how to call do-smooth-scroll after 
;; the cursor moved into the margin, but so far couldn't figure out how
;; (enable-smooth-scroll-for-function evil-scroll-up)
;; (enable-smooth-scroll-for-function evil-scroll-down)
;; 
;; (enable-smooth-scroll-for-function scroll-down)
;; (enable-smooth-scroll-for-function scroll-up)

;; (defun his-tracing-function (orig-fun &rest args)
;;        (message "orig-fun called with args %S" args)
;;        ;; (let ((res (apply orig-fun args)))
;;        ;;   (message "orig-fun returned %S" res)
;;        ;;   res)
;;        (apply orig-fun)
;;        (do-smooth-scroll)
;; )

(add-hook 'python-mode-hook 'smooth-scrolling-mode)
)

#+END_SRC

#+RESULTS:
: t

** beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :config
  (add-hook 'python-mode-hook 'beacon-mode))
#+END_SRC
** crux 
Some commands are re-defined so that they are (may be) more convenient (in certain situations).
#+BEGIN_SRC emacs-lisp
(use-package crux
  :ensure t
  :config
  ;; (global-set-key [remap move-beginning-of-line] #'crux-move-beginning-of-line)
  ;; (global-set-key [remap beginning-of-visual-line] #'crux-move-beginning-of-line)
  (global-set-key (kbd "C-a") #'crux-move-beginning-of-line)
  (global-set-key (kbd "C-c d") #'crux-duplicate-current-line-or-region)
  )
#+END_SRC

#+RESULTS:
: t

** free-keys
Show free key bindings in a particular mode combination.  
#+BEGIN_SRC emacs-lisp
(use-package free-keys 
  :ensure t
  :config
)
#+END_SRC

** COMMENT auto-dim-other-buffers
#+BEGIN_SRC emacs-lisp
  (use-package auto-dim-other-buffers
    :ensure t
    :config
    (add-hook 'after-init-hook (lambda ()
                                 (when (fboundp 'auto-dim-other-buffers-mode)
                                   (auto-dim-other-buffers-mode t)))))
#+END_SRC

#+RESULTS:
: t

** multiple-cursors
Provide multiple cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :config
    (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
    (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click))
#+END_SRC

#+RESULTS:
: t

** flash-region
#+BEGIN_SRC emacs-lisp
  (use-package flash-region
    :ensure t)
#+END_SRC

#+RESULTS:

** COMMENT interleave
#+BEGIN_SRC emacs-lisp
  (use-package interleave
    :ensure t
    :config
    (defun my-interleave-hook ()
    (with-current-buffer interleave-org-buffer
      ;; Do something meaningful here
      (message "Hi there. I'm in the org buffer!")))

    (add-hook 'interleave-mode-hook #'my-interleave-hook))
#+END_SRC

#+RESULTS:

** org-noter
#+BEGIN_SRC emacs-lisp
  (use-package org-noter
    :ensure t
    :config
    (define-key org-noter-doc-mode-map (kbd "C-M-, h") 'org-noter-set-hide-other)
    (define-key org-noter-notes-mode-map (kbd "C-M-, h") 'org-noter-set-hide-other)

    ;; toggle off an org-noter session
    (define-key org-noter-notes-mode-map (kbd "C-M-, C-M-n") 'org-noter)
    (define-key org-noter-notes-mode-map (kbd "C-M-, C-M-k")
      (lambda ()
        (unless (fboundp 'elscreen-get-current-screen)
          (org-noter-kill-session))))
    ;; if you run elscreen, never do org-noter-kill-session
    (define-key org-noter-doc-mode-map (kbd "C-M-, C-M-n") 'org-noter)
    (define-key org-noter-doc-mode-map (kbd "C-M-, C-M-k")
      (lambda ()
        (unless (fboundp 'elscreen-get-current-screen)
          (org-noter-kill-session))))

    ;; start one fresh
    (define-key org-mode-map (kbd "C-M-, C-M-n") 'org-noter)
    (define-key pdf-view-mode-map (kbd "C-M-, C-M-n") 'org-noter)

    ;; insert notes
    ;; (define-key org-mode-map (kbd "C-M-, C-M-n") 'org-noter)
    ;; (define-key org-noter-notes-mode-map (kbd "C-M-, C-M-i") 'org-noter-insert-note)
    ;; (define-key org-noter-notes-mode-map (kbd "C-M-, C-M-i") 'org-noter-insert-note)
    ;; (define-key org-noter-doc-mode-map (kbd "C-M-, C-M-p") 'org-noter-insert-precise-note)
    ;; (define-key org-noter-doc-mode-map (kbd "C-M-, C-M-p") 'org-noter-insert-precise-note)

    (define-key org-noter-doc-mode-map (kbd "i") 'org-noter-insert-note)

    ;; don't force org-noter sessions into always a new frame
    (setq org-noter-always-create-frame nil)

    ;; my convention: I don't want to be distracted by questions
    (setq org-noter-insert-note-no-questions t)

    ;; my convention: put the org file as a hidden file right next to the pdf
    (setq org-noter-notes-search-path '())
    )
#+END_SRC

#+RESULTS:
: t

** golden-ratio
#+BEGIN_SRC emacs-lisp
  (use-package golden-ratio
    :ensure t
    :config
    (setq golden-ratio-auto-scale t))
#+END_SRC

#+RESULTS:
: t

** windmove
#+BEGIN_SRC emacs-lisp
  (use-package windmove
    :ensure t
    :config
    ;; (windmove-default-keybindings)
    (global-set-key (kbd "s-k") 'windmove-up)
    (global-set-key (kbd "s-j") 'windmove-down)
    (global-set-key (kbd "s-h") 'windmove-left)
    (global-set-key (kbd "s-l") 'windmove-right)
    ;; other-window (cycle)
    (global-set-key (kbd "s-n") (lambda () (interactive) (other-window 1)))
    ;; (global-set-key (kbd "s-p") (lambda () (interactive) (other-window -1)))
    )
#+END_SRC

#+RESULTS:
: t

* programming general behaviour
#+BEGIN_SRC emacs-lisp
(require 'cc-mode)

;; automatically indent when press RET
(global-set-key (kbd "RET") 'newline-and-indent)

;; activate whitespace-mode to view all whitespace characters
(global-set-key (kbd "C-c w") 'whitespace-mode)

;; show unncessary whitespace that can mess up your diff
(add-hook 'prog-mode-hook (lambda () (interactive) (setq show-trailing-whitespace 1)))

;; use space to indent by default
(setq-default indent-tabs-mode nil)

;; set appearance of a tab that is represented by 4 spaces
(setq-default tab-width 4)

;; navigate through matches in list (may it be compilation messages or tag occurrences)
(global-set-key (kbd "C-, k") (lambda () (interactive) (next-match -1)))
(global-set-key (kbd "C-, j") (lambda () (interactive) (next-match +1)))

(define-key c++-mode-map (kbd "C-, z") 'compile)
(define-key c-mode-map (kbd "C-, z") 'compile)

(add-hook 'prog-mode-hook 'visual-line-mode)
#+END_SRC

#+RESULTS:
| visual-line-mode | (lambda nil (interactive) (setq show-trailing-whitespace 1)) |

** python
#+BEGIN_SRC emacs-lisp
(defun printbreakpoint ()
  (interactive)
  (insert "import ipdb; ipdb.set_trace()  # noqa BREAKPOINT<C-c>"))

(add-hook 'python-mode-hook 
          (lambda () 
            (define-key python-mode-map (kbd "C-, b") 'printbreakpoint)))
#+END_SRC

#+RESULTS:
| (lambda nil (define-key python-mode-map (kbd C-, b) (quote printbreakpoint))) | beacon-mode |

** latex
#+BEGIN_SRC emacs-lisp
(add-hook 'latex-mode 'show-paren-mode)
#+END_SRC

#+RESULTS:
| show-paren-mode |

** c/c++
#+BEGIN_SRC emacs-lisp
;; Deal with indentation, tabs and white spaces

;; Available C style:
;; “gnu”: The default style for GNU projects
;; “k&r”: What Kernighan and Ritchie, the authors of C used in their book
;; “bsd”: What BSD developers use, aka “Allman style” after Eric Allman.
;; “whitesmith”: Popularized by the examples that came with Whitesmiths C, an early commercial C compiler.
;; “stroustrup”: What Stroustrup, the author of C++ used in his book
;; “ellemtel”: Popular C++ coding standards as defined by “Programming in C++, Rules and Recommendations,” Erik Nyquist and Mats Henricson, Ellemtel
;; “linux”: What the Linux developers use for kernel development
;; “python”: What Python developers use for extension modules
;; “java”: The default style for java-mode (see below)
;; “user”: When you want to define your own style
(setq c-default-style "linux")

(add-hook 'c-mode-hook 'flycheck-mode)
(add-hook 'c++-mode-hook 'flycheck-mode)

;; c/c++ debugging workspace setup
;; use gdb-many-windows by default
(setq gdb-many-windows t)
;; Non-nil means display source file containing the main routine at startup
(setq gdb-show-main t)
#+END_SRC

#+RESULTS:
: t

** emacs-lisp
Bind some keys and some hooks
#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (define-key emacs-lisp-mode-map (kbd "C-, e") 'eval-buffer)
  (define-key emacs-lisp-mode-map (kbd "C-M-<") (lambda () (transpose-sexps -1)))
  (define-key emacs-lisp-mode-map (kbd "C-M->") (lambda () (transpose-sexps +1)))
  (define-key emacs-lisp-mode-map (kbd "C-, e") 'eval-buffer)
#+END_SRC

#+RESULTS:
: eval-buffer

* programming packages
** generally useful
*** yasnippet
#+BEGIN_SRC emacs-lisp
    (use-package yasnippet
      :config
      (yas-global-mode)
      ;; hack to get it to expand after non-whitespace
      (modify-syntax-entry 36 " " org-mode-syntax-table)
      (modify-syntax-entry 92 "w" org-mode-syntax-table)
      ;; (add-hook 'org-mode-hook #'my-org-latex-yas)
      (setq yas-triggers-in-field t)
      (setq yas-maybe-expand nil)

      (defvar cs/default-snippet-dir "~/.emacs.d/snippets")
    
      ;; exclusively put snippets in here, so it's not scattered
      (setq yas-snippet-dirs (list cs/default-snippet-dir))

      ;; i find it annoying to edit yasnippet snippet files in the usual way
      ;; so now i use helm and fuzzy matching
      (defun yas-find-snippet-file ()
        "Find snippet file with fuzzy matching."
        (interactive)
        (find-file-other-window  (helm-read-file-name
                                  "Select snippet: "
                                  :initial-input (concat
                                                  (expand-file-name cs/default-snippet-dir)
                                                  "/ ")
                                  ;; :marked-candidates t
                                  ))))
#+END_SRC

#+RESULTS:
: t

*** projectile	
#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
  (projectile-mode +1)
  (define-key projectile-mode-map (kbd "s-p") 'projectile-command-map)
  (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map))
#+END_SRC

#+RESULTS:
: t


*** ialign
#+BEGIN_SRC emacs-lisp
(use-package ialign
  :ensure t
  :config
  (global-set-key (kbd "C-x l") #'ialign))
#+END_SRC

#+RESULTS:
: t

*** COMMENT clean-aindent-mode
#+BEGIN_SRC emacs-lisp
(use-package clean-aindent-mode
  :config
  (add-hook 'prog-mode-hook 'clean-aindent-mode))
#+END_SRC

#+RESULTS:

*** ws-butler
#+BEGIN_SRC emacs-lisp
(use-package ws-butler
  :config
  (add-hook 'c-mode-common-hook 'ws-butler-mode)
  (add-hook 'emacs-lisp-mode-hook 'ws-butler-mode))
#+END_SRC

#+RESULTS:
: t

*** smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :config
  (show-smartparens-global-mode +1)
  (smartparens-global-mode 1)
  
  ;; when you press RET, the curly braces automatically
  ;; add another newline
  (sp-with-modes '(c-mode c++-mode)
  (sp-local-pair "{" nil :post-handlers '(("||\n[i]" "RET")))
  (sp-local-pair "/*" "*/" :post-handlers '((" | " "SPC")
                                            ("* ||\n[i]" "RET")))))
#+END_SRC

#+RESULTS:
: t

*** evil-paredit
It is difficult to debug elisp code in the usual packages when in evil-mode, so even though I am installing some packages here that are supposed to make that easier, it's really not. 
#+BEGIN_SRC emacs-lisp
(use-package evil-paredit 
:ensure t
:config 
;; (add-hook 'emacs-lisp-mode-hook 'evil-paredit-mode)
;; (progn 
;;   (define-key evil-paredit-mode-map (kbd "C-)") 'paredit-forward-slurp-sexp)
;;   (define-key evil-paredit-mode-map (kbd "C-(") 'paredit-backward-slurp-sexp)
;;   (define-key evil-paredit-mode-map (kbd "C-8") 'paredit-backward-barf-sexp)
;;   (define-key evil-paredit-mode-map (kbd "C-9") 'paredit-forward-barf-sexp))
)
#+END_SRC

#+RESULTS:
: t

*** COMMENT evil-cleverparens
#+BEGIN_SRC emacs-lisp
(use-package evil-cleverparens
:ensure t
:config 
;; (add-hook 'emacs-lisp-mode-hook 'evil-cleverparens-mode)
)
#+END_SRC
*** stickyfunc-enhance
#+BEGIN_SRC emacs-lisp
(use-package stickyfunc-enhance
  :ensure t)
#+END_SRC

#+RESULTS:

*** origami
implements folding for many modes
#+BEGIN_SRC emacs-lisp
(use-package origami 
  :ensure t
  :config
  (add-hook 'python-mode-hook 'origami-mode)
  (add-hook 'emacs-lisp-mode-hook 'origami-mode)
  (require 'python)
  (define-key python-mode-map (kbd "S-<iso-lefttab>") 'origami-toggle-all-nodes)
  (define-key emacs-lisp-mode-map (kbd "S-<iso-lefttab>") 'origami-toggle-all-nodes)
  (define-key emacs-lisp-mode-map (kbd "TAB") 'origami-toggle-node)
)
#+END_SRC

#+RESULTS:
: t

** latex
*** auctex
#+BEGIN_SRC emacs-lisp
(use-package tex
  :defer t
  :ensure auctex
  :config
    (setq TeX-auto-save t)
    ;; in latex-mode with auctex, don't use fancy fontification for math
    (setq tex-fontify-script nil)
    (setq font-latex-fontify-script nil)
    
    ;; also don't use big ugly headings
    (setq font-latex-fontify-sectioning 'color)
    (setq font-latex-fontify-sectioning 1.0))
#+END_SRC

#+RESULTS:

** python
*** py-autopep8
#+BEGIN_SRC emacs-lisp
(use-package py-autopep8
  :ensure t)
#+END_SRC

#+RESULTS:

*** elpy
#+BEGIN_SRC emacs-lisp
(use-package elpy
  :config
  (elpy-enable)

  ;; switch out flymake for flycheck (less troubleshooting, real-time syntax checking)
  (when (require 'flycheck nil t)
    (setq elpy-modules (delq 'elpy-module-flymake elpy-modules))
    (add-hook 'elpy-mode-hook 'flycheck-mode))

  (add-hook 'python-mode-hook 'elpy-mode)
  (with-eval-after-load 'elpy
  (remove-hook 'elpy-modules 'elpy-module-flymake)
  (add-hook 'elpy-mode-hook 'flycheck-mode))
  ;; (add-hook 'elpy-mode-hook 'elpy-use-ipython)
  ;; (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)

  ;; ;; switch out the standard python interpreter with jupyter 
  ;; (setq python-shell-interpreter "jupyter"
  ;;       python-shell-interpreter-args "console --simple-prompt"
  ;;       python-shell-prompt-detect-failure-warning nil)
  ;; (add-to-list 'python-shell-completion-native-disabled-interpreters
  ;;              "jupyter")

  (defun goto-def-or-rgrep ()
    "Go to definition of thing at point or do an rgrep in project if that fails"
    (interactive)
    (condition-case nil (elpy-goto-definition)
      (error (elpy-rgrep-symbol (thing-at-point 'symbol)))))

  ;; (add-hook 'python-mode-hook
  ;;       '(lambda() (global-set-key (kbd "C-, d") 'elpy-goto-definition)))

  (add-hook 'python-mode-hook
        '(lambda() (global-set-key (kbd "C-, d") 'goto-def-or-rgrep)))
)
#+END_SRC

#+RESULTS:
: t

*** pyvenv
#+BEGIN_SRC emacs-lisp
(use-package pyvenv
  :ensure t
  :init
  (setenv "WORKON_HOME" "~/venvs")
  (pyvenv-mode 1)
  (pyvenv-tracking-mode 1))

#+END_SRC

#+RESULTS:

*** shell-pop
#+BEGIN_SRC emacs-lisp
(use-package shell-pop
  :config
  (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
  (setq shell-pop-term-shell "/bin/zsh")
  ;; need to do this manually or not picked up by `shell-pop'
  (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
  (global-set-key (kbd "C-, t") 'shell-pop)
)
#+END_SRC

#+RESULTS:
: t
*** elisp-slime-nav
#+BEGIN_SRC emacs-lisp
(use-package elisp-slime-nav
 :ensure t
 :config 

  (defun elisp-slime-nav-register-jump-to-definition () 
    (interactive)
    (global-set-key (kbd "C-, d") (lambda () (interactive) (call-interactively 'elisp-slime-nav-find-elisp-thing-at-point))))

  (dolist (hook '(emacs-lisp-mode-hook ielm-mode-hook))
    (add-hook hook 'elisp-slime-nav-mode)
    (add-hook hook 'elisp-slime-nav-register-jump-to-definition))
)
#+END_SRC

#+RESULTS:
: t

** c/c++
*** flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
:ensure t
:config 
(add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
(setq-default flycheck-emacs-lisp-load-path 'inherit)
)
#+END_SRC

#+RESULTS:
: t

*** ggtags
#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  ;; :pin melpa-stable   ; didn't work
  :config
    (require 'ggtags)
    (add-hook 'c-mode-common-hook
              (lambda ()
                (when (derived-mode-p 'c-mode 'c++-mode 'java-mode 'asm-mode)
                  (ggtags-mode 1))))
    
    (define-key ggtags-mode-map (kbd "C-c g s") 'ggtags-find-other-symbol)
    (define-key ggtags-mode-map (kbd "C-c g h") 'ggtags-view-tag-history)
    (define-key ggtags-mode-map (kbd "C-c g r") 'ggtags-find-reference)
    (define-key ggtags-mode-map (kbd "C-c g f") 'ggtags-find-file)
    (define-key ggtags-mode-map (kbd "C-c g c") 'ggtags-create-tags)
    (define-key ggtags-mode-map (kbd "C-c g u") 'ggtags-update-tags)
    (define-key ggtags-mode-map (kbd "C-, d") 'ggtags-find-tag-dwim)
    (define-key ggtags-mode-map (kbd "C-, ,") 'pop-tag-mark)

    ;; (define-key ggtags-mode-map (kbd "M-,") 'pop-tag-mark)
    ;; (setq-local imenu-create-index-function #'ggtags-build-imenu-index)
)
#+END_SRC

#+RESULTS:
: t

*** function-args
#+BEGIN_SRC emacs-lisp
(use-package function-args
  :ensure t
  :config
  (fa-config-default))
#+END_SRC

#+RESULTS:
: t

*** helm-gtags
#+BEGIN_SRC emacs-lisp
(use-package helm-gtags
  :ensure t
  :config
    ;;; Enable helm-gtags-mode
    (add-hook 'c-mode-hook 'helm-gtags-mode)
    (add-hook 'c++-mode-hook 'helm-gtags-mode)
    (add-hook 'asm-mode-hook 'helm-gtags-mode)

    ;; customize
    (custom-set-variables
    '(helm-gtags-path-style 'relative)
    '(helm-gtags-ignore-case t)
    '(helm-gtags-auto-update t))

    ;; key bindings
    (with-eval-after-load 'helm-gtags
    (define-key helm-gtags-mode-map (kbd "M-t") 'helm-gtags-find-tag)
    (define-key helm-gtags-mode-map (kbd "M-r") 'helm-gtags-find-rtag)
    (define-key helm-gtags-mode-map (kbd "M-s") 'helm-gtags-find-symbol)
    (define-key helm-gtags-mode-map (kbd "M-g M-p") 'helm-gtags-parse-file)
    (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
    (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history)
    (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)))
#+END_SRC

#+RESULTS:
: t

*** company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  (require 'cc-mode)
  (add-hook 'after-init-hook 'global-company-mode)
  (setq company-backends (delete 'company-semantic company-backends))
  (define-key c-mode-map  [(tab)] 'company-complete)
  (define-key c++-mode-map  [(tab)] 'company-complete)
  ;; Weirdly, I didn't manually have to specify all my includes,
  ;; maybe because projectile works with it?
  ;; ((nil . ((company-clang-arguments . ("-I/home/<user>/project_root/include1/"
                                       ;; "-I/home/<user>/project_root/include2/")))))
)
#+END_SRC

#+RESULTS:
: t

*** company-c-headers
#+BEGIN_SRC emacs-lisp
(use-package company-c-headers
  :ensure t
  :config
  (with-eval-after-load "company"
    (add-to-list 'company-backends 'company-c-headers)
    (add-to-list 'company-c-headers-path-system "/usr/include/c++/7.3.0/")))

#+END_SRC

#+RESULTS:
: t

*** semantic
#+BEGIN_SRC emacs-lisp
(use-package semantic
  :config
  (require 'cc-mode) ;; at least I think this include belongs here

  (add-to-list 'semantic-default-submodes 'global-semantic-stickyfunc-mode)

  (semantic-mode 1)

  (global-semanticdb-minor-mode 1)
  (global-semantic-idle-scheduler-mode 1)
  ;; optionally, add company-semantic as company mode backend
  ;; for language-aware code completion templates

  ;; You can use semantic to parse
  ;; and enable jumping to other-than-project-local source files
  (semantic-add-system-include "/usr/local/include")
  ;; (It takes a while at first, but is fast afterwards) You may use semantic 
  ;; in combination with GNU Global and ggtags
  ;; (semantic-add-system-include "~/linux/include")
)
#+END_SRC

#+RESULTS:
: t
*** python-mode
#+BEGIN_SRC emacs-lisp
  (defun python-execute-main-in-terminal()
    (interactive)
    ;; usually the popup-shell has name *ansi-term-1* where, 1 is the index
    (setq index 1)
    (comint-send-string (shell-pop--shell-buffer-name index) "python3 main.py\n"))
  
  (define-key term-mode-map (kbd "C-, z") 'python-execute-main-in-terminal)
  (define-key python-mode-map (kbd "C-, z") 'python-execute-main-in-terminal)
#+END_SRC

#+RESULTS:
: python-execute-main-in-terminal
** Emacs-Lisp
*** flycheck
Complains about unconventional style when writing emacs-lisp packages. 
#+BEGIN_SRC emacs-lisp
(add-hook 'emacs-lisp-mode-hook #'flycheck-mode)
(define-key emacs-lisp-mode-map (kbd "C-c i") 'indent-sexp)
#+END_SRC

#+RESULTS:
: indent-sexp

*** semantic-refactor for lisp 
This tool is based on semantic. It doesn't really refactor, but it can e.g. reformat a whole emacs-lisp buffer. This is potentially also useful for C/C++.
#+BEGIN_SRC emacs-lisp
(use-package srefactor
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook 
             (lambda () 
               (require 'srefactor)
               (require 'srefactor-lisp)
               (semantic-mode 1))))
#+END_SRC

* COMMENT literature research packages
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/sword-to-org")
(require 'sword-to-org)

(add-to-list 'load-path "~/.emacs.d/diatheke.el")
(require 'diatheke)

(add-to-list 'load-path "~/.emacs.d/etxt")
(require 'etxt)
#+END_SRC

#+RESULTS:
: etxt
** silver searcher ag
#+BEGIN_SRC emacs-lisp

#+END_SRC

#+RESULTS:

* general utility functions
#+BEGIN_SRC emacs-lisp
(defun list-packages-and-versions ()
  "Returns a list of all installed packages and their versions"
  (mapcar
   (lambda (pkg)
     `(,pkg ,(package-desc-version
                (cadr (assq pkg package-alist)))))
   package-activated-list))

(defun google-quickly()
  "Googles a query or region if any."
  (interactive)
  (browse-url
   (concat
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q="
    (if mark-active
        (buffer-substring (region-beginning) (region-end))
      (read-string "Google: ")))))

(global-set-key (kbd "C-x g") 'google-quickly)


(defun outside-terminal-with-tmux ()
  (interactive)
  (shell-command "gnome-terminal -e 'tmux new' >/dev/null"))

(global-set-key (kbd "C-x C-m C-t") 'outside-terminal-with-tmux)

(defun outside-explorer ()
  (interactive)
  (setq s (concat "nautilus " (file-name-directory buffer-file-name) " & "))
  (message s)
  (call-process-shell-command s nil 0))

(global-set-key (kbd "C-x C-m C-f") 'outside-explorer)  ; open gui file explorer

(defun outside-browser ()
  (interactive)
  (setq s (concat "chromium-browser " (file-name-directory buffer-file-name) " & "))
  (message s)
  (call-process-shell-command s nil 0)
)

(global-set-key (kbd "C-x C-m C-b") 'outside-browser)  ; open browser at that file

(defun kill-non-visible-buffers ()
  "Kill all buffers not currently shown in a window somewhere."
  (interactive)
  (dolist (buf  (buffer-list))
    (unless (get-buffer-window buf 'visible) (kill-buffer buf))))

(defun new-buffer-frame ()
  "Create a new frame with a new empty buffer."
  (interactive)
  (let ((buffer (generate-new-buffer "untitled")))
    (set-buffer-major-mode buffer)
    (display-buffer buffer '(display-buffer-pop-up-frame . nil))))

(global-set-key (kbd "C-c n") #'new-buffer-frame)

;; search for the current folder's desktop-setup.el file, load it and execute the create-project-desktop-setup function

#+END_SRC

#+RESULTS:
: start-project

* documentation packages
*** org-elisp-help
#+BEGIN_SRC emacs-lisp
(use-package org-elisp-help
:ensure t
)
#+END_SRC

#+RESULTS:

* COMMENT phased out right now
#+BEGIN_SRC emacs-lisp
(defun kill-all-but-shown ()
  (interactive)
  (delete-other-frames)
  (kill-non-visible-buffers))

(defun kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer 
          (delq (current-buffer) 
                (remove-if-not 'buffer-file-name (buffer-list)))))

(defun halve-other-window-height ()
  "Expand current window to use half of the other window's lines."
  (interactive)
  (enlarge-window (/ (window-height (next-window)) 2)))

(global-set-key (kbd "C-, h") 'halve-other-window-height)

(defun my-echo ()
  (interactive)
  ;; usually the popup-shell has name *ansi-term-1* where, 1 is the index
  (setq index 1)
  (switch-to-buffer (shell-pop--shell-buffer-name index))
  (end-of-buffer)
  (insert "echo hello")
  (term-send-input))

;; insert current buffers file path into minibuffer 
(define-key minibuffer-local-map [f3]
  (lambda () (interactive) 
     (insert (buffer-name (window-buffer (minibuffer-selected-window))))))
#+END_SRC

#+RESULTS:
| lambda | nil | (interactive) | (insert (buffer-name (window-buffer (minibuffer-selected-window)))) |

* COMMENT under construction
#+BEGIN_SRC emacs-lisp
(setq helm-buffers-fuzzy-matching t
      helm-recentf-fuzzy-match    t)
#+END_SRC

* Klin
#+BEGIN_SRC emacs-lisp

  ;; (use-package klin  ; not in melpa, must be manually put in the load path
  ;; :load-path (expand-file-name "~/Dropbox/stuff/klin"))

  (add-to-list 'load-path (expand-file-name "~/Dropbox/stuff/klin/"))
  (require 'klin)
#+END_SRC

#+RESULTS:
: klin

* Tabbing
** COMMENT Tabbar
Tabbar for simple pdf switching
#+BEGIN_SRC emacs-lisp
  (use-package tabbar
    :ensure t
    :config
    )
#+END_SRC

#+RESULTS:
** elscreen
#+BEGIN_SRC emacs-lisp
    (use-package elscreen
      :ensure t
      :config
      (elscreen-start)
      )

  ;; (use-package elscreen-tab  ; incompatible with Emacs 25.2.2 (see package-list-packages)
  ;;   :ensure t
  ;;   :config (require 'elscreen-tab)(elscreen-tab-mode))
#+END_SRC

#+RESULTS:
: t
